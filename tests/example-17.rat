fn HigherOrder(f: fn (Int, Int) -> Int, x: Int, y: Int) -> Int {
  return f(x, y);
}

fn Clojure(x0: Int) -> fn (Int) -> Int {
  let mut y: Int = x0;
  return | x: Int | -> Int  { y = y + x; return y; };
}

fn Add(x: Int, y: Int) -> Int {
  return x + y;
}

fn Lambdas() -> Void {
  let x: Int = 14;
  let lambda1: fn(Int) -> Int = | x: Int | -> Int  { return x + 1; };

  Println(lambda1(x));

  let lambda2: fn(Int) -> fn(Int) -> Int = | x: Int | -> fn (Int) -> Int  {
    return | y: Int | -> Int { return Add(x, y); };
  };


  let fun1: fn(Int) -> Int = lambda2(1);
  let fun2: fn (Int) -> Int = lambda2(3);
  Println(fun1(16));
  Println(fun2(16));

  return;
}


fn Main() -> Void {
  Println(HigherOrder(Add, 4, 5));
  let c: fn(Int) -> Int = Clojure(10);
  Println(ShowInt(c(1)));
  Println(ShowInt(c(2)));
  Lambdas();
  return;
}